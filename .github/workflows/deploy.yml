name: Deploy to Stage

on:
  push:
    branches: ['master', 'main']
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    name: Build and push Docker image to GHCR
    runs-on: ubuntu-latest
    environment: stage
    permissions:
      contents: read
      packages: write
    outputs:
      repo_owner_lc: ${{ steps.lowercase.outputs.repo_owner_lc }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Convert repository owner to lowercase
        id: lowercase
        run: |
          echo "repo_owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          build-args: |
            BASE_PATH=${{ vars.BASE_PATH }}
          tags: |
            ${{ env.REGISTRY }}/${{ steps.lowercase.outputs.repo_owner_lc }}/threejs-demo:stage-${{ github.sha }}
            ${{ env.REGISTRY }}/${{ steps.lowercase.outputs.repo_owner_lc }}/threejs-demo:stage-latest

  deploy:
    name: Deploy to Stage server
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: stage

    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGE_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p 49152 -H ${{ vars.STAGE_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory on server
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            mkdir -p ${{ vars.STAGE_DEPLOY_PATH }}
          EOF

      - name: Copy docker-compose file to server
        run: |
          scp -P 49152 -i ~/.ssh/deploy_key docker-compose.stage.yml \
            ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }}:${{ vars.STAGE_DEPLOY_PATH }}/

      - name: Create .env file on server
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            cat > ${{ vars.STAGE_DEPLOY_PATH }}/.env << 'ENVEOF'
          REGISTRY=${{ env.REGISTRY }}
          REPO_OWNER=${{ needs.build-and-push.outputs.repo_owner_lc }}
          IMAGE_TAG=stage-${{ github.sha }}
          STAGE_DOMAIN=${{ vars.STAGE_DOMAIN }}
          BASE_PATH=${{ vars.BASE_PATH }}
          ENVEOF
          EOF

      - name: Login to GHCR on server
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} \
            "echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin" 2>/dev/null

      - name: Pull Docker image
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            cd ${{ vars.STAGE_DEPLOY_PATH }}
            docker compose -f docker-compose.stage.yml --env-file .env pull
          EOF

      - name: Deploy application
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            cd ${{ vars.STAGE_DEPLOY_PATH }}
            docker compose -f docker-compose.stage.yml --env-file .env up -d
          EOF

      - name: Wait for service to start
        run: sleep 20

      - name: Health check with auto-rollback
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            cd ${{ vars.STAGE_DEPLOY_PATH }}

            # Health check function
            check_health() {
              curl -k -f https://${{ vars.STAGE_DOMAIN }}/threejs-demo/api/health 2>/dev/null || \
              curl -f http://${{ vars.STAGE_DOMAIN }}/threejs-demo/api/health 2>/dev/null || \
              echo "failed"
            }

            # Try health check
            HEALTH_RESULT=$(check_health)

            if [[ "$HEALTH_RESULT" != *"ok"* ]]; then
              echo "❌ Health check failed! Result: $HEALTH_RESULT"
              echo "Container logs:"
              docker logs threejs-demo-stage --tail 50
              exit 1
            else
              echo "✅ Health check passed"
            fi
          EOF

      - name: Verify deployment
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            echo "=== Docker container status ==="
            docker ps --filter "name=threejs-demo-stage" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo -e "\n=== Health check result ==="
            curl -k -s https://${{ vars.STAGE_DOMAIN }}/threejs-demo/api/health || echo "Failed"
          EOF

      - name: Cleanup old Docker images
        if: success()
        run: |
          ssh -p 49152 -i ~/.ssh/deploy_key ${{ vars.STAGE_SERVER_USER }}@${{ vars.STAGE_SERVER_HOST }} << 'EOF'
            echo "=== Removing old images ==="
            docker images ${{ env.REGISTRY }}/${{ needs.build-and-push.outputs.repo_owner_lc }}/threejs-demo --format "{{.ID}}" | tail -n +3 | xargs -r docker rmi -f 2>/dev/null || true
          EOF

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
